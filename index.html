<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>TEDS COLOR PALETTES</title>
    <link rel="icon" href="favicon.svg" type="image/svg+xml" />
  <script type="importmap">
{
  "imports": {
    "react/": "https://aistudiocdn.com/react@^19.2.0/",
    "react": "https://aistudiocdn.com/react@^19.2.0",
    "react-dom/": "https://aistudiocdn.com/react-dom@^19.2.0/",
    "@google/genai": "https://aistudiocdn.com/@google/genai@^1.27.0"
  }
}
</script>
<!-- Add Babel Standalone for in-browser JSX/TSX transpilation -->
<script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

<style>
/* BUNDLED CSS - ALL STYLES ARE NOW INLINED */

/* --- From index.css --- */
body {
  margin: 0;
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
    'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',
    sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  background-color: #111827; /* bg-gray-900 */
}

*, *::before, *::after {
  box-sizing: border-box;
}

#root {
  height: 100vh;
  width: 100vw;
}

@keyframes spin {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}

.animate-spin {
  animation: spin 1s linear infinite;
}

/* --- From App.css --- */
.app-container {
  background-color: #111827;
  height: 100vh;
  width: 100vw;
  overflow: hidden;
  display: flex;
  flex-direction: column;
}

.main-content {
  flex-grow: 1;
  display: flex;
  flex-direction: column;
}

@media (min-width: 768px) {
  .main-content {
    flex-direction: row;
  }
}

.loading-overlay-full {
  position: absolute;
  top: 0; right: 0; bottom: 0; left: 0;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  background-color: rgba(17, 24, 39, 0.8);
  z-index: 20;
}

.loading-icon-large {
  width: 4rem;
  height: 4rem;
  color: white;
}

.loading-text {
  color: white;
  margin-top: 1rem;
  font-size: 1.125rem;
}

.loading-overlay-partial {
  position: absolute;
  top: 0; right: 0; bottom: 0; left: 0;
  display: flex;
  align-items: center;
  justify-content: center;
  background-color: rgba(0, 0, 0, 0.5);
  z-index: 20;
}

.loading-icon-small {
  width: 3rem;
  height: 3rem;
  color: white;
}

.error-message {
  position: absolute;
  bottom: 1rem;
  left: 50%;
  transform: translateX(-50%);
  background-color: #ef4444;
  color: white;
  padding: 0.75rem 1.5rem;
  border-radius: 0.5rem;
  box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
  z-index: 50;
}

.spacebar-hint {
  position: fixed;
  bottom: 1.25rem;
  left: 50%;
  transform: translateX(-50%);
  background-color: #1f2937;
  color: #d1d5db;
  padding: 0.5rem 1rem;
  border-radius: 9999px;
  font-size: 0.875rem;
  opacity: 0.75;
  display: none;
}

@media (min-width: 768px) {
  .spacebar-hint {
    display: block;
  }
}

.spacebar-hint kbd {
  font-family: ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji";
  border: 1px solid #4b5563;
  background-color: #374151;
  color: #e5e7eb;
  border-radius: 0.375rem;
  padding: 0.25rem 0.5rem;
  margin: 0 0.25rem;
}

/* --- From components/ColorColumn.css --- */
.color-column {
  flex: 1;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  padding: 1rem;
  transition: all 300ms ease-in-out;
  position: relative;
  min-width: 0;
}

.primary-label {
  position: absolute;
  top: 1rem;
  font-size: 0.75rem;
  font-weight: bold;
  text-transform: uppercase;
  letter-spacing: 0.1em;
  padding: 0.25rem 0.75rem;
  border-radius: 9999px;
  transition: opacity 200ms ease-in-out;
}

/* Hide primary label on hover/focus for cleaner UI */
.color-column:has(.color-info:hover) .primary-label,
.color-column:has(.hex-code-input:focus) .primary-label {
  opacity: 0;
  pointer-events: none;
}

.color-info {
  text-align: center;
  transition: opacity 300ms;
  opacity: 0;
  width: 100%;
  max-width: 200px;
}

.color-column:hover .color-info {
  opacity: 1;
}

@media (min-width: 768px) {
  .color-column {
    padding: 2rem;
  }
  .color-info {
    opacity: 1;
  }
}

.hex-code {
  font-size: 1.5rem;
  font-weight: bold;
  letter-spacing: 0.05em;
  margin-bottom: 1rem;
  text-transform: uppercase;
  cursor: pointer;
}

@media (min-width: 768px) {
  .hex-code {
    font-size: 1.875rem;
  }
}

/* Styles for the new editable input */
.hex-code-input {
  /* Mimic h2 styles */
  font-family: inherit;
  font-size: 1.5rem;
  font-weight: bold;
  letter-spacing: 0.05em;
  text-transform: uppercase;
  
  /* Input-specific styles */
  background: transparent;
  border: none;
  border-bottom: 2px solid transparent;
  width: 100%;
  padding: 0;
  margin-bottom: calc(1rem - 2px); /* Account for border */
  text-align: center;
  outline: none;
  transition: border-color 150ms ease-in-out;
}

.hex-code-input:focus {
  border-bottom: 2px solid currentColor;
}

@media (min-width: 768px) {
  .hex-code-input {
    font-size: 1.875rem;
  }
}

.actions {
  display: flex;
  gap: 1rem;
  justify-content: center;
}

.action-button {
  padding: 0.75rem;
  border-radius: 9999px;
  transition: background-color 200ms;
  background: none;
  border: none;
  color: inherit;
  cursor: pointer;
}

.action-button:hover {
  background-color: rgba(0, 0, 0, 0.2);
}

.action-button:focus-visible {
  outline: none;
  box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.5);
}

.icon {
  width: 1.5rem;
  height: 1.5rem;
  display: block;
}

.icon-check {
  color: #4ade80;
}

/* --- From components/Header.css --- */
.app-header {
  padding: 1rem;
  background-color: #111827;
  color: white;
  z-index: 10;
  width: 100%;
  display: flex;
  align-items: center;
  justify-content: space-between;
  flex-shrink: 0;
}

.title-container {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
}

.app-title {
  font-size: 1.5rem;
  font-weight: bold;
  letter-spacing: -0.025em;
}

.youtube-link {
  color: #9ca3af;
  text-decoration: none;
  font-size: 0.75rem;
  margin-top: 0.1rem;
  transition: color 200ms;
}

.youtube-link:hover {
  color: #e5e7eb;
  text-decoration: underline;
}

.app-title .c { color: #f87171; }
.app-title .o1 { color: #facc15; }
.app-title .l { color: #4ade80; }
.app-title .o2 { color: #818cf8; }
.app-title .r { color: #f472b6; }
.app-title .palettes { color: #60a5fa; }

.header-action-button {
  padding: 0.5rem;
  border-radius: 9999px;
  transition: background-color 200ms;
  background: none;
  border: none;
  color: inherit;
  cursor: pointer;
}

.header-action-button:hover {
  background-color: #374151;
}

.header-action-button:focus-visible {
  outline: none;
  box-shadow: 0 0 0 2px #60a5fa;
}

.header-action-button .icon {
  width: 1.5rem;
  height: 1.5rem;
  display: block;
}


/* --- From components/Toast.css --- */
.toast {
  position: fixed;
  top: 5rem;
  left: 50%;
  background-color: #22c55e;
  color: white;
  padding: 0.75rem 1.5rem;
  border-radius: 0.5rem;
  box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25);
  transition: all 300ms ease-in-out;
  z-index: 50;
  opacity: 0;
  transform: translateX(-50%) translateY(-1.25rem);
  pointer-events: none;
}

.toast.visible {
  opacity: 1;
  transform: translateX(-50%) translateY(0);
}

/* --- From components/HistoryPanel.css --- */
.history-overlay {
  position: fixed;
  top: 0; right: 0; bottom: 0; left: 0;
  background-color: rgba(0, 0, 0, 0.5);
  z-index: 30;
  transition: opacity 300ms;
  opacity: 0;
  pointer-events: none;
}

.history-overlay.open {
  opacity: 1;
  pointer-events: auto;
}

.history-panel {
  position: fixed;
  top: 0;
  right: 0;
  height: 100%;
  width: 20rem; /* w-80 */
  background-color: #1f2937; /* bg-gray-800 */
  color: white;
  box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
  z-index: 40;
  transform: translateX(100%);
  transition: transform 300ms ease-in-out;
}

.history-panel.open {
  transform: translateX(0);
}

.panel-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 1rem;
  border-bottom: 1px solid #374151; /* border-gray-700 */
}

.panel-title {
  font-size: 1.25rem;
  font-weight: 600;
}

.close-button {
  padding: 0.5rem;
  border-radius: 9999px;
  transition: background-color 200ms;
  background: none;
  border: none;
  color: inherit;
  cursor: pointer;
  line-height: 0;
}

.close-button:hover {
  background-color: #374151;
}

.close-button .icon {
  width: 1.5rem;
  height: 1.5rem;
}

.panel-content {
  padding: 1rem;
  overflow-y: auto;
  height: calc(100% - 65px);
}

.empty-history {
  color: #9ca3af; /* text-gray-400 */
  text-align: center;
  margin-top: 2rem;
}

.history-list {
  padding: 0;
  margin: 0;
  list-style: none;
  display: flex;
  flex-direction: column;
  gap: 1rem;
}

.history-item {
  cursor: pointer;
}

.palette-preview {
  display: flex;
  height: 3rem;
  border-radius: 0.5rem;
  overflow: hidden;
  border: 2px solid transparent;
  transition: all 150ms;
}

.history-item:hover .palette-preview {
  border-color: #60a5fa; /* border-blue-400 */
}

.palette-swatch {
  width: 20%;
  height: 100%;
}
</style>
<link rel="stylesheet" href="/index.css">
</head>
  <body>
    <div id="root"></div>
    <script type="text/babel" data-type="module">
// BUNDLED SCRIPT - ALL TSX/JS IS NOW INLINED

// --- External Imports ---
import React, { useState, useEffect, useCallback } from 'react';
import ReactDOM from 'react-dom/client';

// --- From utils/color.ts ---
const getContrastingTextColor = (hex) => {
  if (!hex) return 'white';

  const cleanHex = hex.startsWith('#') ? hex.slice(1) : hex;
  const r = parseInt(cleanHex.substring(0, 2), 16);
  const g = parseInt(cleanHex.substring(2, 4), 16);
  const b = parseInt(cleanHex.substring(4, 6), 16);

  // Formula for luminance
  const luminance = (0.299 * r + 0.587 * g + 0.114 * b) / 255;

  return luminance > 0.5 ? 'black' : 'white';
};

// --- From utils/paletteGenerator.ts ---
const hexToRgb = (hex) => {
  const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
  return result
    ? {
        r: parseInt(result[1], 16),
        g: parseInt(result[2], 16),
        b: parseInt(result[3], 16),
      }
    : { r: 0, g: 0, b: 0 };
};

const rgbToHsl = (r, g, b) => {
  r /= 255;
  g /= 255;
  b /= 255;
  const max = Math.max(r, g, b);
  const min = Math.min(r, g, b);
  let h = 0, s = 0, l = (max + min) / 2;

  if (max !== min) {
    const d = max - min;
    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
    switch (max) {
      case r: h = (g - b) / d + (g < b ? 6 : 0); break;
      case g: h = (b - r) / d + 2; break;
      case b: h = (r - g) / d + 4; break;
    }
    h /= 6;
  }
  return { h: h * 360, s, l };
};

const hslToRgb = (h, s, l) => {
  let r, g, b;
  h /= 360;
  if (s === 0) {
    r = g = b = l;
  } else {
    const hue2rgb = (p, q, t) => {
      if (t < 0) t += 1;
      if (t > 1) t -= 1;
      if (t < 1 / 6) return p + (q - p) * 6 * t;
      if (t < 1 / 2) return q;
      if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
      return p;
    };
    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
    const p = 2 * l - q;
    r = hue2rgb(p, q, h + 1 / 3);
    g = hue2rgb(p, q, h);
    b = hue2rgb(p, q, h - 1 / 3);
  }
  return { r: Math.round(r * 255), g: Math.round(g * 255), b: Math.round(b * 255) };
};

const rgbToHex = (r, g, b) => {
  const toHex = (c) => ('0' + Math.round(c).toString(16)).slice(-2);
  return `#${toHex(r)}${toHex(g)}${toHex(b)}`.toUpperCase();
};

const generateHarmoniousColor = (baseHue, scheme, index, total) => {
    let h = baseHue;
    switch(scheme) {
        case 'analogous':
            h = (baseHue + 30 * (index - Math.floor(total / 2))) % 360;
            break;
        case 'monochromatic':
            break;
        case 'triadic':
            h = (baseHue + 120 * index) % 360;
            break;
        case 'complementary':
            h = (baseHue + 180 * (index % 2) + (Math.random() - 0.5) * 20) % 360;
            break;
    }
    if (h < 0) h += 360;

    const s = 0.45 + Math.random() * 0.5;
    const l = (scheme === 'monochromatic') 
        ? 0.2 + (index / total) * 0.7 + (Math.random() * 0.1 - 0.05)
        : 0.3 + Math.random() * 0.5;

    const { r, g, b } = hslToRgb(h, s, l);
    return rgbToHex(r, g, b);
};

const generateLocalPalette = (lockedColors = []) => {
  // Map locked colors first. The first locked color (if any) is primary.
  const finalPalette = lockedColors.map((hex, index) => ({ 
    hex, 
    isPrimary: index === 0 
  }));
  
  const numToGenerate = 5 - lockedColors.length;
  
  if (numToGenerate <= 0) {
    return finalPalette.slice(0, 5);
  }

  const baseHue = lockedColors.length > 0
    ? rgbToHsl(hexToRgb(lockedColors[0]).r, hexToRgb(lockedColors[0]).g, hexToRgb(lockedColors[0]).b).h
    : Math.random() * 360;
  
  const schemes = ['analogous', 'monochromatic', 'triadic', 'complementary'];
  const chosenScheme = schemes[Math.floor(Math.random() * schemes.length)];

  const allHexCodes = new Set(lockedColors.map(c => c.toUpperCase()));

  for (let i = 0; i < numToGenerate; i++) {
    let newHex;
    let attempts = 0;
    do {
      newHex = generateHarmoniousColor(baseHue, chosenScheme, i, numToGenerate).toUpperCase();
      attempts++;
    } while (allHexCodes.has(newHex) && attempts < 20);
    
    allHexCodes.add(newHex);
    finalPalette.push({
      hex: newHex,
      // The first generated color is primary ONLY if there are no locked colors.
      isPrimary: lockedColors.length === 0 && i === 0,
    });
  }

  return finalPalette;
};

// --- From components/Icons.tsx ---
const LockIcon = (props) => (
  <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}>
    <rect x="3" y="11" width="18" height="11" rx="2" ry="2"></rect>
    <path d="M7 11V7a5 5 0 0 1 10 0v4"></path>
  </svg>
);
const UnlockIcon = (props) => (
  <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}>
    <rect x="3" y="11" width="18" height="11" rx="2" ry="2"></rect>
    <path d="M7 11V7a5 5 0 0 1 9.9-1"></path>
  </svg>
);
const CopyIcon = (props) => (
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}>
        <rect width="14" height="14" x="8" y="8" rx="2" ry="2"></rect>
        <path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path>
    </svg>
);
const LoadingIcon = (props) => (
  <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}>
    <path d="M21 12a9 9 0 1 1-6.219-8.56" />
  </svg>
);
const PaletteIcon = (props) => (
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}>
        <circle cx="13.5" cy="6.5" r=".5" fill="currentColor"></circle>
        <circle cx="17.5" cy="10.5" r=".5" fill="currentColor"></circle>
        <circle cx="8.5" cy="7.5" r=".5" fill="currentColor"></circle>
        <circle cx="6.5" cy="12.5" r=".5" fill="currentColor"></circle>
        <path d="M12 2C6.5 2 2 6.5 2 12s4.5 10 10 10c.926 0 1.648-.746 1.648-1.688 0-.437-.18-.835-.437-1.125-.29-.289-.438-.652-.438-1.125a1.64 1.64 0 0 1 1.668-1.668h1.996c3.051 0 5.555-2.503 5.555-5.554C21.965 6.012 17.461 2 12 2z"></path>
    </svg>
);
const CheckIcon = (props) => (
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="3" strokeLinecap="round" strokeLinejoin="round" {...props}>
        <path d="M20 6 9 17l-5-5"></path>
    </svg>
);
const HistoryIcon = (props) => (
  <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}>
    <path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8" />
    <path d="M3 3v5h5" />
    <path d="M12 7v5l4 2" />
  </svg>
);
const CloseIcon = (props) => (
  <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}>
    <line x1="18" y1="6" x2="6" y2="18"></line>
    <line x1="6" y1="6" x2="18" y2="18"></line>
  </svg>
);

// --- From components/Toast.tsx ---
const Toast = ({ message }) => {
  const [visible, setVisible] = useState(false);
  useEffect(() => {
    if (message) {
      setVisible(true);
      const timer = setTimeout(() => {
        setVisible(false);
      }, 1900);
      return () => clearTimeout(timer);
    } else {
      setVisible(false);
    }
  }, [message]);
  return (
    <div className={`toast ${visible ? 'visible' : ''}`}>
      {message}
    </div>
  );
};

// --- From components/HistoryPanel.tsx ---
const HistoryPanel = ({ isOpen, onClose, history, onSelectPalette }) => {
  return (
    <React.Fragment>
      <div
        className={`history-overlay ${isOpen ? 'open' : ''}`}
        onClick={onClose}
      ></div>
      <aside
        className={`history-panel ${isOpen ? 'open' : ''}`}
      >
        <div className="panel-header">
          <h2 className="panel-title">History</h2>
          <button
            onClick={onClose}
            className="close-button"
            aria-label="Close history panel"
          >
            <CloseIcon className="icon" />
          </button>
        </div>
        <div className="panel-content">
          {history.length === 0 ? (
            <p className="empty-history">
              No history yet. Generate a new palette using the button in the header!
            </p>
          ) : (
            <ul className="history-list">
              {history.map((palette, index) => (
                <li
                  key={index}
                  onClick={() => onSelectPalette(palette)}
                  className="history-item"
                >
                  <div className="palette-preview">
                    {palette.map((color) => (
                      <div
                        key={color.hex}
                        className="palette-swatch"
                        style={{ backgroundColor: color.hex }}
                      />
                    ))}
                  </div>
                </li>
              ))}
            </ul>
          )}
        </div>
      </aside>
    </React.Fragment>
  );
};

// --- From components/Header.tsx ---
const Header = ({ onToggleHistory, onGeneratePalette }) => {
  return (
    <header className="app-header">
      <button
        onClick={onGeneratePalette}
        className="header-action-button"
        aria-label="Generate new palette"
      >
        <PaletteIcon className="icon" />
      </button>
      <div className="title-container">
        <h1 className="app-title">
          TEDS{' '}
          <span className="c">C</span>
          <span className="o1">O</span>
          <span className="l">L</span>
          <span className="o2">O</span>
          <span className="r">R</span>{' '}
          <span className="palettes">PALETTES</span>
        </h1>
        <a 
          href="https://youtube.com/@tedsworldprojects" 
          target="_blank" 
          rel="noopener noreferrer"
          className="youtube-link"
        >
          @tedsworldprojects
        </a>
      </div>
      <button
        onClick={onToggleHistory}
        className="header-action-button"
        aria-label="View palette history"
      >
        <HistoryIcon className="icon" />
      </button>
    </header>
  );
};

// --- From components/ColorColumn.tsx ---
const ColorColumn = ({ color, isLocked, onToggleLock, onCopy, onPrimaryColorUpdate }) => {
  const [justCopied, setJustCopied] = useState(false);
  const [editedHex, setEditedHex] = useState(color.hex);
  const textColor = getContrastingTextColor(color.hex);

  useEffect(() => {
    setEditedHex(color.hex);
  }, [color.hex]);

  const handleCopyClick = () => {
    onCopy();
    setJustCopied(true);
    setTimeout(() => setJustCopied(false), 1500);
  };
  
  const handleHexChange = (e) => {
    setEditedHex(e.target.value);
  };

  const handleHexSubmit = (e) => {
    if (e.key === 'Enter') {
      if (/^#?([0-9A-F]{6})$/i.test(editedHex)) {
        const formattedHex = (editedHex.startsWith('#') ? editedHex : `#${editedHex}`).toUpperCase();
        if (formattedHex !== color.hex) {
          onPrimaryColorUpdate?.(formattedHex);
        }
      } else {
        setEditedHex(color.hex); // Revert on invalid format
      }
      e.target.blur();
    }
    if (e.key === 'Escape') {
      setEditedHex(color.hex);
      e.target.blur();
    }
  };
  
  const handleBlur = () => {
    setEditedHex(color.hex);
  };

  return (
    <div
      className="color-column"
      style={{ backgroundColor: color.hex, color: textColor }}
    >
      {color.isPrimary && (
        <div
          className="primary-label"
          style={{
            backgroundColor: 'rgba(255, 255, 255, 0.2)',
            color: textColor,
          }}
        >
          Primary
        </div>
      )}
      <div className="color-info">
        {color.isPrimary && onPrimaryColorUpdate ? (
          <input
            type="text"
            className="hex-code-input"
            value={editedHex}
            onChange={handleHexChange}
            onKeyDown={handleHexSubmit}
            onBlur={handleBlur}
            style={{ color: 'inherit' }}
            aria-label="Editable primary hex code"
          />
        ) : (
          <h2 className="hex-code" onClick={handleCopyClick}>
            {color.hex}
          </h2>
        )}
        <div className="actions">
          <button
            onClick={onToggleLock}
            className="action-button"
            aria-label={isLocked ? 'Unlock color' : 'Lock color'}
          >
            {isLocked ? (
              <LockIcon className="icon" />
            ) : (
              <UnlockIcon className="icon" />
            )}
          </button>
          <button
            onClick={handleCopyClick}
            className="action-button"
            aria-label="Copy color hex code"
          >
             {justCopied ? (
              <CheckIcon className="icon icon-check" />
            ) : (
              <CopyIcon className="icon" />
            )}
          </button>
        </div>
      </div>
    </div>
  );
};

// --- From App.tsx ---
const App = () => {
  const [palette, setPalette] = useState([]);
  const [lockedColors, setLockedColors] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const [copiedHex, setCopiedHex] = useState(null);
  const [paletteHistory, setPaletteHistory] = useState([]);
  const [isHistoryPanelOpen, setIsHistoryPanelOpen] = useState(false);

  const handleGeneratePalette = useCallback((overrideLockedColors) => {
    setLoading(true);
    setError(null);
    try {
      if (palette.length > 0) {
        setPaletteHistory(prev => [palette, ...prev.slice(0, 9)]);
      }
      
      let colorsToLock = Array.isArray(overrideLockedColors) ? overrideLockedColors : lockedColors;

      // Sort the locked colors based on their current position in the palette
      // to ensure the first one visually becomes the new primary.
      if (!overrideLockedColors && colorsToLock.length > 1) {
          const sortedLockedColors = [...colorsToLock].sort((a, b) => {
              const indexA = palette.findIndex(c => c.hex === a);
              const indexB = palette.findIndex(c => c.hex === b);
              // if a color isn't found (shouldn't happen), keep it at the end
              if (indexA === -1) return 1;
              if (indexB === -1) return -1;
              return indexA - indexB;
          });
          colorsToLock = sortedLockedColors;
      }

      const newPalette = generateLocalPalette(colorsToLock);
      setPalette(newPalette);

    } catch (err) {
      setError(err instanceof Error ? err.message : 'An unknown error occurred.');
      console.error(err);
    } finally {
      setLoading(false);
    }
  }, [lockedColors, palette]);

  useEffect(() => {
    handleGeneratePalette();
  }, []);

  useEffect(() => {
    const handleKeyDown = (event) => {
      const target = event.target;
      if (event.code === 'Space' && !['INPUT', 'TEXTAREA'].includes(target.tagName)) {
        event.preventDefault();
        handleGeneratePalette();
      }
    };

    window.addEventListener('keydown', handleKeyDown);
    return () => {
      window.removeEventListener('keydown', handleKeyDown);
    };
  }, [handleGeneratePalette]);

  const handleToggleLock = (hex) => {
    setLockedColors(prev =>
      prev.includes(hex) ? prev.filter(h => h !== hex) : [...prev, hex]
    );
  };

  const handleCopy = (hex) => {
    navigator.clipboard.writeText(hex);
    setCopiedHex(hex);
    setTimeout(() => setCopiedHex(null), 2000);
  };

  const handleToggleHistory = () => {
    setIsHistoryPanelOpen(prev => !prev);
  };

  const handleSelectFromHistory = (selectedPalette) => {
    setPalette(selectedPalette);
    setLockedColors([]); 
    setIsHistoryPanelOpen(false);
  };

  const handlePrimaryColorUpdate = (newHex) => {
    const formattedHex = newHex.startsWith('#') ? newHex : `#${newHex}`;
    setLockedColors([formattedHex]);
    handleGeneratePalette([formattedHex]);
  };

  return (
    <div className="app-container">
      <Header onToggleHistory={handleToggleHistory} onGeneratePalette={() => handleGeneratePalette()} />
      <main className="main-content">
        {loading && palette.length === 0 ? (
          <div className="loading-overlay-full">
            <LoadingIcon className="loading-icon-large animate-spin" />
            <p className="loading-text">Generating your first palette...</p>
          </div>
        ) : (
          palette.map(color => (
            <ColorColumn
              key={color.hex}
              color={color}
              isLocked={lockedColors.includes(color.hex)}
              onToggleLock={() => handleToggleLock(color.hex)}
              onCopy={() => handleCopy(color.hex)}
              onPrimaryColorUpdate={handlePrimaryColorUpdate}
            />
          ))
        )}
      </main>
      
      {loading && palette.length > 0 && (
        <div className="loading-overlay-partial">
           <LoadingIcon className="loading-icon-small animate-spin" />
        </div>
      )}

      {error && (
        <div className="error-message">
          <p><strong>Error:</strong> {error}</p>
        </div>
      )}

      <HistoryPanel
        isOpen={isHistoryPanelOpen}
        onClose={handleToggleHistory}
        history={paletteHistory}
        onSelectPalette={handleSelectFromHistory}
      />
      
      <div className="spacebar-hint">
        Press <kbd>Spacebar</kbd> to generate a new palette
      </div>
      
      <Toast message={copiedHex ? `Copied ${copiedHex} to clipboard!` : null} />
    </div>
  );
};

// --- From index.tsx ---
const rootElement = document.getElementById('root');
if (!rootElement) {
  throw new Error("Could not find root element to mount to");
}

const root = ReactDOM.createRoot(rootElement);
root.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);
    </script>
  <script type="module" src="/index.tsx"></script>
</body>
</html>